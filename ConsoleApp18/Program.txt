using System;

namespace GeneticAlgorithm
{

    class Program
    {
        static void Main(string[] args)
        {
            Random rd = new Random(DateTime.Now.Millisecond);

            AlgoObject program = new AlgoObject(800, 350, 20, 40, "C:\\Users\\piotr\\source\\repos\\Google Drive Sync\\Genetic Algorithm\\ConsoleApp18\\Map.txt", rd);
            program.Run();
        }
    }

    struct Position
    {
        public int x { get; set; }
        public int y { get; set; }
    }

    class Specimen
    {
        public int tabSizeC;
        private int tabSizeB;

        public Position pos;

        public char[] genTabC { get; set; }
        public byte[] genTabB { get; set; }

        public double fitness { get; set; }

        public Specimen(int genSize, Random globalRandom)
        {
            tabSizeC = genSize;
            tabSizeB = tabSizeC * 2;

            genTabC = new char[tabSizeC];
            genTabB = new byte[tabSizeB];

            pos.x = 0;
            pos.y = 0;

            for(int i = 0; i < tabSizeB; i++)
            {
                genTabB[i] = (byte)globalRandom.Next(0, 2);
            }

            this.Convert();
        }

        public void PrintB()
        {
            for(int i = 0; i < tabSizeB; i++)
            {
                Console.Write(genTabB[i]);
            }
            Console.WriteLine();
        }

        public void PrintC()
        {
            for(int i = 0; i < tabSizeC; i++)
            {
                Console.Write(genTabC[i]);
            }
            Console.WriteLine();
        }

        public void Mutate(int place)
        {
            if(genTabB[place] == 0)
            {
                genTabB[place] = 1;
            }
            else
            {
                genTabB[place] = 0;
            }
        }

        public Specimen Crossover(Specimen parent1, Random rd)
        {
            // Stwórz nowego potomka, zachowując materiał genetyczny z obu rodziców
            Specimen child = new Specimen(this.tabSizeC, new Random());

            // Losowe krzyżowanie z obu rodziców
            for (int i = 0; i < this.genTabB.Length; i++)
            {
                child.genTabB[i] = (rd.NextDouble() < 0.5)
                    ? this.genTabB[i]
                    : parent1.genTabB[i];
            }

            child.Convert();
            return child;
        }
        public void Fitness(Position actualPosition, Position endPosition,Position mapBoundries, int traversedTiles, bool reachedEnd)
        {
            // Obliczenie odległości euklidesowej od celu
            double distance = Math.Sqrt(Math.Pow(actualPosition.x - endPosition.x, 2) + Math.Pow(actualPosition.y - endPosition.y, 2));
            double maxDistance = Math.Sqrt(Math.Pow(mapBoundries.x - 1, 2) + Math.Pow(mapBoundries.y - 1, 2));

            // Fitness zależny od odległości (im bliżej celu, tym wyższy fitness)
            double howFar = 1 - (distance / maxDistance);

            double progressBonus = 1.0 - (Math.Abs(actualPosition.x - endPosition.x) + Math.Abs(actualPosition.y - endPosition.y))
                            / (mapBoundries.x + mapBoundries.y);

            // Dodatkowy bonus za dotarcie do celu
            if (reachedEnd)
            {
                fitness += 0.5; // Możesz zmienić na inną wartość, aby zwiększyć wagę
            }

            // Kara za odwiedzanie pól (proporcjonalna do liczby odwiedzonych pól)
            double penalty = Math.Min(0.1, 0.001 * traversedTiles);
            fitness -= penalty;

            fitness = 1.0 - (distance / maxDistance);



            fitness = Math.Max(0, fitness - penalty);
        }

        public void Convert()
        {
            for (int i = 0; i < tabSizeC; i++)
            {
                int index = i / 2;
                if (genTabB[index * 2] == 0)
                {
                    if (genTabB[index * 2 + 1] == 0)
                    {
                        genTabC[i] = 'L';
                    }
                    else
                    {
                        genTabC[i] = 'D';
                    }
                }
                else
                {
                    if (genTabB[index * 2 + 1] == 0)
                    {
                        genTabC[i] = 'R';
                    }
                    else
                    {
                        genTabC[i] = 'U';
                    }
                }
            }
        }
    }

    class Population
    {
        public Specimen[] speciments { get; set; }
        public Map map { get; set; }

        Position startPos;
        Position endPos;

        Random globalRandom = new Random(DateTime.Now.Millisecond);

        public Population(int popSize ,int genSize, int mapSizeX, int mapSizeY, string path, Random rd)
        {
            speciments = new Specimen[popSize];

            for(int i = 0; i < popSize; i++)
            {
                speciments[i] = new Specimen(genSize, globalRandom);
            }

            map = new Map(mapSizeX, mapSizeY, path);

            for(int x = 0; x < mapSizeX; x++)
            {
                for(int y = 0; y < mapSizeY; y++)
                {
                    if(map.map[x][y] == 'S')
                    {
                        startPos.x = x;
                        startPos.y = y;
                    }
                    else if(map.map[x][y] == 'E')
                    {
                        endPos.x = x;
                        endPos.y = y;
                    }
                }
            }
        }

        public void DebugSort()
        {
            for (int i = 1; i < speciments.Length; i++)
            {
                if (speciments[i].fitness > speciments[i - 1].fitness)
                {
                    Console.WriteLine($"Błąd sortowania: Specimen {i} ma wyższy fitness niż Specimen {i - 1}");
                }
            }
        }

        public void Sort(int low, int high)
        {
            if (low >= high) return;

            double pivot = speciments[high].fitness;
            int i = low;

            for (int j = low; j < high; j++)
            {
                if (speciments[j].fitness >= pivot)
                {
                    // Zamiana miejscami
                    (speciments[i], speciments[j]) = (speciments[j], speciments[i]);
                    i++;
                }
            }

            // Umieść pivot w odpowiednim miejscu
            (speciments[i], speciments[high]) = (speciments[high], speciments[i]);

            // Rekurencyjne sortowanie podlist
            Sort(low, i - 1);
            Sort(i + 1, high);
        }

        public void Show(int specimentNumber)
        {
            //speciments[specimentNumber].PrintB();
            speciments[specimentNumber].PrintC();

            Console.WriteLine("Fitness: " + speciments[specimentNumber].fitness);

            char[][] tempTab = map.map.Select(row => row.ToArray()).ToArray();

            Position actualPos = startPos;

            for (int i = 0; i < speciments[specimentNumber].genTabC.Length; i++)
            {
                switch (speciments[specimentNumber].genTabC[i])
                {
                    case 'L':

                        if (actualPos.x == 0)
                            break;

                        else if (tempTab[actualPos.x - 1][actualPos.y] == ' ')
                        {
                            actualPos.x--;
                            tempTab[actualPos.x][actualPos.y] = '*';
                        }
                        break;

                    case 'R':

                        if(actualPos.x > map.mapBoundries.x - 1)
                            break;

                        else if (tempTab[actualPos.x + 1][actualPos.y] == ' ')
                        {
                            actualPos.x++;
                            tempTab[actualPos.x][actualPos.y] = '*';
                        }
                        break;

                    case 'U':

                        if(actualPos.y == 0)
                            break;

                        else if (tempTab[actualPos.x][actualPos.y - 1] == ' ')
                        {
                            actualPos.y--;
                            tempTab[actualPos.x][actualPos.y] = '*';
                        }
                        break;

                    case 'D':

                        if(actualPos.y > map.mapBoundries.y - 1)
                            break;

                        else if (tempTab[actualPos.x][actualPos.y + 1] == ' ')
                        {
                            actualPos.y++;
                            tempTab[actualPos.x][actualPos.y] = '*';
                        }
                        break;
                }
            }

            for (int i = 0; i < map.mapBoundries.x; i++)
            {
                for (int j = 0; j < map.mapBoundries.y; j++)
                {
                    Console.Write(tempTab[i][j]);
                }
                Console.WriteLine();
            }
        }

        public void Evaluate()
        {
            char[][] tempTab = map.map.Select(row => row.ToArray()).ToArray();

            foreach (Specimen s in speciments)
            {
                Position actualPos = new Position { x = startPos.x, y = startPos.y };
                s.Convert();

                bool[][] visited = new bool[map.mapBoundries.x][];
                for (int i = 0; i < map.mapBoundries.x; i++)
                {
                    visited[i] = new bool[map.mapBoundries.y];
                }

                bool reachedEnd = false;

                for (int i = 0; i < s.genTabC.Length; i++)
                {
                    int traversedTiles = 0;

                    // Wykonaj ruch zgodnie z instrukcjami w genach
                    switch (s.genTabC[i])
                    {
                        case 'L': // Lewo
                            if (actualPos.x > 0 && tempTab[actualPos.x - 1][actualPos.y] != '#')
                            {
                                if(tempTab[actualPos.x - 1][actualPos.y] == '*')
                                    traversedTiles++;

                                actualPos.x--;
                                tempTab[actualPos.x][actualPos.y] = '*';  // Zaznacz nową pozycję
                            } 
                            
                            break;

                        case 'R': // Prawo
                            if (actualPos.x < map.mapBoundries.x - 1 && tempTab[actualPos.x + 1][actualPos.y] != '#')
                            {
                                if(tempTab[actualPos.x + 1][actualPos.y] == '*')
                                    traversedTiles++;

                                actualPos.x++;
                                tempTab[actualPos.x][actualPos.y] = '*';  // Zaznacz nową pozycję
                            }
                            
                            break;

                        case 'U': // Góra
                            if (actualPos.y > 0 && tempTab[actualPos.x][actualPos.y - 1] != '#')
                            {
                                if(tempTab[actualPos.x][actualPos.y - 1] == '*')
                                    traversedTiles++;

                                actualPos.y--;
                                tempTab[actualPos.x][actualPos.y] = '*';  // Zaznacz nową pozycję
                            }
                            
                            break;

                        case 'D': // Dół
                            if (actualPos.y < map.mapBoundries.y - 1 && tempTab[actualPos.x][actualPos.y + 1] != '#')
                            {
                                if (tempTab[actualPos.x][actualPos.y + 1] == '*')
                                    traversedTiles++;

                                actualPos.y++;
                                tempTab[actualPos.x][actualPos.y] = '*';  // Zaznacz nową pozycję)
                            }
                            
                            break;
                    }

                    if(actualPos.x == endPos.x && actualPos.y == endPos.y)
                        reachedEnd = true;

                    // Oblicz wartość przystosowania na bieżąco
                    s.Fitness(actualPos, endPos, map.mapBoundries, traversedTiles, reachedEnd);
                }
            }
        }
    }

    class Map
    {
        public char[][] map { get; set; }
        public Position mapBoundries;

        public Map(int sizeX, int sizeY, string path)
        {
            map = new char[sizeX][];
            for(int i = 0; i < sizeX; i++)
            {
                map[i] = new char[sizeY];
            }

            StreamReader mapFile = new StreamReader(path);
            
            string data = mapFile.ReadToEnd();
            mapFile.Close();

            data = data.Replace("\r\n", "").Replace("\n", "");

            int pos = 0;
            for(int i = 0; i < sizeX; i++)
            {
                for(int j = 0; j < sizeY - 1; j++)
                {
                    map[i][j] = data[pos];
                    pos++;
                }
            }

            mapBoundries.x = sizeX;
            mapBoundries.y = sizeY;
        }
    }

    class AlgoObject
    {
        Population p { get; set; }

        ulong iteration = 0;

        Random rd;

        public AlgoObject(int popSize, int genSize, int mapSizeX, int mapSizeY, string path, Random rdm)
        {
            rd = rdm;
            p = new Population(popSize, genSize, mapSizeX, mapSizeY, path, rd);
        }

        public void Run()
        {
            p.Evaluate();

            p.Sort(0, p.speciments.Length - 1);

            double mutationRate = 0.1;

            for (; ; )
            {
                for (int i = 0; i < p.speciments.Length; i++)
                {
                    for (int j = 0; j < p.speciments[i].genTabB.Length; j++)
                    {
                        if (rd.NextDouble() < mutationRate)
                        {
                            p.speciments[i].Mutate(j);
                        }
                    }
                }

                int spcSize = p.speciments.Length;

                int specimentsToCross = (int)(spcSize * 0.5);

                int[] tab = new int[specimentsToCross];

                for (int i = 0; i < specimentsToCross; i++)
                {
                    int parent1 = rd.Next(0, specimentsToCross);
                    int parent2 = rd.Next(0, specimentsToCross);

                    while (parent1 == parent2)
                    {
                        parent1 = rd.Next(0, specimentsToCross);
                        parent2 = rd.Next(0, specimentsToCross);
                    }


                    p.speciments[parent1] = p.speciments[parent1].Crossover(p.speciments[parent2],rd);

                    tab[i] = parent1;
                }

                p.Evaluate();

                p.Sort(0, p.speciments.Length - 1);

                StreamWriter sw = new StreamWriter("C:\\Users\\piotr\\Desktop\\Specimens.txt", true);
                sw.WriteLine("Generation: " + iteration + " | " + p.speciments[0].fitness);
                sw.Close();

                if (iteration % 5 == 0)
                {
                    Console.Clear();
                    Console.WriteLine("Generation: " + iteration);
                    iteration++;
                    p.Show(0);
                }
                iteration++;
            }
        }
    }
}
